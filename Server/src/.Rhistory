if(! "Row" %in% meta$location) return("No row metadata")
# Return if formating does not distinguish differences within a row/column in which
# a difference is asserted
# eg if subgroup names nad subgroup labels have exactly the same fomratting
meta_distinct <- meta %>%
select(location, number, first_col, indent, bold,  italic, plain, first_last_col) %>%
distinct()
meta_d1 <- meta %>%
group_by(location, number) %>%
count()
meta_d2 <- meta_distinct %>%
group_by(location, number) %>%
count() %>%
rename(x = n)
suppressWarnings(suppressMessages(meta_d3 <- meta_d1 %>%
inner_join(meta_d2) %>%
filter(n >x) %>%
rename(`Number of identified groups` = n, `Number of distinct formatting` = x) ))
if(nrow(meta_d3) >=1) return(list(warning = meta_d3))
filename <- paste(meta$docid[1], meta$page[1], sep = "_")
if(file.exists(paste0(tablesDirectory, filename, ".xlsx"))){
all_cells <- xlsx_cells(paste0(tablesDirectory, filename, ".xlsx"))
} else {
all_cells <- new_obj %>% filter( pmid_tbl == filename)
}
#all_cells2 <- new_obj
#all_cells2 %>% select(colnames(all_cells)) -> all_cells
# rectify(all_cells)
##  Simplify table by making all values character
# If no numeric or no character columns, create
if(!"numeric"   %in% names(all_cells)) all_cells <- all_cells %>% mutate(numeric = NA)
if(!"character" %in% names(all_cells)) all_cells <- all_cells %>% mutate(chracter = NA)
all_cells <- all_cells %>%
mutate(data_type = if_else(is.na(character) & !is.na(numeric), "character", data_type),
character = if_else(is.na(character), as.character(numeric), character))
## Extract cell-level formatting
if(file.exists(paste0(tablesDirectory, filename, ".xlsx"))){
formats <- xlsx_formats(paste0(tablesDirectory, filename, ".xlsx"))
bold <- formats$local$font$bold
ital <- formats$local$font$italic
bold_ital <- bind_cols(formats$local$font[c("bold", "italic")])
## Note indentation is relative to minimum indent, problem is that this refers to every cell,
## not just column_type
indt <- bind_cols(formats$local$alignment) %>%
mutate(indent = indent - min(indent),
indent_lvl = indent,
indent = horizontal %in% c("center", "right") |
(indent >=1)) %>%
select(indent, indent_lvl)
} else {
formats <- new_obj %>% filter( pmid_tbl == filename) %>% select(bold, italic,"indent","indent_lvl")
# totalRows <- all_cells$character_formatted %>% length
bold <- formats$bold
italic <- formats$italic
bold_ital <- cbind(bold,italic) %>% as_tibble
indt <- formats %>% select("indent","indent_lvl")
# all_cells <- all_cells %>% mutate(local_format_id = seq_along(local_format_id))
all_cells <- all_cells %>% mutate(local_format_id = seq_along(all_cells$row))
#
# for ( r in 1:totalRows ) {
#
#   obj <- all_cells$character_formatted[[r]]
#   bold <- c(bold, obj$bold)
#   ital <- c(ital, obj$italic)
#
# }
#
# browser()
#
#
# indt <- bind_cols(formats$local$alignment) %>%
#   mutate(indent = indent - min(indent),
#          indent_lvl = indent,
#          indent = horizontal %in% c("center", "right") |
#            (indent >=1)) %>%
#   select(indent, indent_lvl)
}
## Append to main dataset
formats <- bind_cols(bold_ital, indt) %>%
mutate(local_format_id = seq_along(bold))
suppressWarnings(suppressMessages(all_cells <- all_cells %>%
inner_join(formats)))
all_cells_indnt <- all_cells %>%
filter(indent) %>%
distinct(row, col, indent_lvl)
all_cells <- all_cells %>%
select(-indent_lvl)
## Extract character formatting (can vary within cells) and aggregate to cell level, take any formatting
# all_cells <- all_cells %>%
#   mutate(char_format_id = seq_along(row))
# characters <- all_cells$character_formatted
# names(characters) <- all_cells$char_format_id
# characters <- bind_rows(characters, .id = "char_format_id")
# characters <- characters %>%
#   select(char_format_id, bold, italic, character) %>%
#   mutate(char_format_id = as.integer(char_format_id)) %>%
#   mutate_at(vars(bold, italic), function(x) if_else(is.na(x), FALSE, x)) %>%
#   group_by(char_format_id) %>%
#   summarise(character = paste(character, collapse = "_|_"),
#             bold = any(bold),
#             italic = any(italic)) %>%
#   ungroup()
#
#
# suppressWarnings(suppressMessages(characters <- all_cells %>%
#   select(char_format_id) %>%
#   left_join(characters) %>%
#   mutate(bold = if_else(is.na(bold), FALSE, bold),
#          italic = if_else(is.na(italic), FALSE, italic)) %>%
#   rename(bold_char = bold,
#          italic_char = italic)))
#
# suppressWarnings(suppressMessages(all_cells <- all_cells %>%
#   left_join(characters) %>%
#   mutate(bold = bold|bold_char,
#          italic = italic|italic_char) %>%
#   select(sheet, address, row, col, is_blank:character, bold, italic, indent)))
# browser()
# all_cells <- all_cells %>% select(sheet, address, row, col, is_blank:character, bold, italic, indent, data_type)
## Identify different types of empty row form completely empty of numbers
# to ones where the first columns alone are not empty
# to ones where the first and last columns are not empty
## First pad the dataframe by adding back in null cells, the package omits some empty cells
## ONly do so where the row or the column is already present
all_cells_pad <- expand.grid(row = 1:max(all_cells$row), col = 1:max(all_cells$col))
suppressWarnings(suppressMessages(all_cells_pad <- all_cells_pad %>%
as_tibble() %>%
semi_join(all_cells %>% distinct(row)) %>%
semi_join(all_cells %>% distinct(col)) ))
suppressWarnings(suppressMessages(all_cells_pad <- all_cells_pad %>%
left_join(all_cells) %>%
mutate(is_blank  = if_else(is.na(is_blank), TRUE, is_blank),
data_type = if_else(is.na(data_type), "blank", data_type),
sheet = sheet[1],
address = paste0(LETTERS[row], col)) ))
all_cells <- all_cells_pad
rm(all_cells_pad)
## First check that all cells are either blank or character
if(all(all_cells$data_type %in% c("character", "blank", "numeric"))) {
all_cells <- all_cells %>%
select(sheet, address, row, col, is_blank, character, bold, italic, indent, data_type) %>%
mutate(is_empty   = is_blank | (!str_detect(character %>% str_to_lower(), "[:alnum:]")),
has_no_num = is_blank | (!str_detect(character %>% str_to_lower(), "[0-9]")))
} else return("Not all cells are character, numeric or blank, code will not work")
# rectify(all_cells)
BlankRow <- function (mydf) {
empty_rows <- mydf %>%
arrange(row, col) %>%
group_by(row) %>%
summarise(blank_row = all(is_empty)) %>%
ungroup() %>%
filter(blank_row) %>%
distinct(row) %>%
pull(row)
}
## Identify split_header_row as the last empty row IN the first set of contiguos empty rows
empty_rows <- BlankRow(all_cells)
null_rows <- setdiff(1:max(all_cells$row), all_cells$row)
empty_rows <- c(empty_rows, null_rows) %>%
sort()
empty_rows <- tibble(empty_rows = empty_rows, diff = lead(empty_rows, default = 1000L) - empty_rows)
empty_rows <- empty_rows %>%
filter(diff != 1)
split_header <- empty_rows$empty_rows[1]
# Next identify any rows which are completely blank
blank_row <- all_cells %>%
BlankRow()
# Those which have no information after removing the first column, except a little text in some of the second columns
first_col_1 <- all_cells %>%
filter(!col %in% 1:2) %>%
BlankRow()
first_col_1_spill <- all_cells %>%
filter(col == 2, has_no_num) %>%
distinct(row) %>%
pull(row)
## This allows for text only, but not numbers in the second column
first_col <- intersect(first_col_1, first_col_1_spill)
# Those which have no information after removing the first and last column
first_last_col <- all_cells %>%
group_by(row) %>%
mutate(col_max = max(col)) %>%
ungroup() %>%
filter(!col %in% 1:2, col != col_max) %>%
BlankRow()
first_last_col  <- intersect(first_last_col, first_col_1_spill)
# Those which have only one cell containing information, after removing the first and last column,
# and which are long rows (>= 4 blank cells)
first_last_col_wide <- all_cells %>%
group_by(row) %>%
mutate(col_max = max(col)) %>%
ungroup() %>%
filter(!col %in% 1:2, col != col_max) %>%
group_by(row) %>%
summarise(few_p = sum(is_blank) >= 4) %>%
filter(few_p) %>%
pull(row)
first_last_col_wide <- intersect(first_last_col_wide, first_col_1_spill)
first_last_col <- union(first_last_col, first_last_col_wide)
first_col <- setdiff(first_col, blank_row)
first_last_col <- setdiff(first_last_col, c(first_col, blank_row))
## Add these onto all_cells
all_cells <- all_cells %>%
mutate(blank_row = row %in% blank_row,
first_col = row %in% first_col,
first_last_col = row %in% first_last_col)
## Take cells before first blank_row as table/figure name
## Take after this cut-point the table body
## reset the table body to reflect the new row 1 (same as in table annotator)
if(length(split_header)==0) {
return("Error no blank row of cells to separate data from figure name")} else{
table_header <- all_cells %>%
filter(row < split_header) %>%
pull(character)
table_body <- all_cells %>%
filter(row > split_header) %>%
mutate(row = row - split_header)
}
## Also need to resent indent level
all_cells_indnt <- all_cells_indnt %>%
filter(row > split_header) %>%
mutate(row = row - split_header)
# table_header
# rectify(table_body)
########### Above this point common to all tables, provided extracted correctly
########### hereafter will depend upon metadata
if(any(meta$location == "Col" & meta$number ==2)) print("Note two columns here, this is unusual")
## take table data component from within table body by excluding row-labels and columns-labels
## With a twist. P-interaction columns contain data, so should not be excluded. There may be other cases. so watch out. #####!!!!#####
meta_for_tdata <- meta %>% filter( ! ( location == "Col" & content == 'p-interaction' & number > 1))
table_body <- table_body %>% mutate( col = col - (min(table_body$col ) -1)) %>% mutate( row = row - (min(table_body$row ) -1)) ## Correction of tables making sure we start in col and row 1.
table_data <- table_body %>%
filter(! row %in% meta_for_tdata$number[meta_for_tdata$location == "Row"],
! col %in% meta_for_tdata$number[meta_for_tdata$location == "Col"])
# rectify(table_data)
## Arrange the metadata so that the most rich row and column qualifying descriptions precede the simplest
## tg from bold and itallics, take out itallics (for example) leaving only bold, then bold out leaving only plain, etc
## Merge column headers, first merge using qualifiers if there are any, if there are none, merge regardless
col_lbls_meta <- meta %>%
filter(location == "Col") %>%
mutate(i = seq_along(location)) %>%
rename(col = number)
## remove uninformative metadata, where all formatting is consistent in an entire row/column label
# col_lbls_meta2 <- col_lbls_meta %>%
#   group_by(col) %>%
#   summarise_at(vars(bold, first_col, first_last_col, indent, italic, plain), all) %>%
#   ungroup()
#
# col_lbls_meta2 <- map2(col_lbls_meta, col)
row_lbls_meta <- meta %>%
filter(location == "Row") %>%
mutate(i = seq_along(location)) %>%
rename(row = number)
col_lbls <- table_body %>%
filter(col %in% col_lbls_meta$col,
!row %in% row_lbls_meta$row)
row_col_cross <- table_body %>%
filter(col %in% col_lbls_meta$col,
row %in% row_lbls_meta$row)
# rectify(col_lbls)
## If all of column labels are indented, attempt to resolve by comparing levels of indentation
if(all(col_lbls$indent) & any(col_lbls_meta$indent)) {
## where there is no indent level, this must be right or centre aligned, give that the maximimal level
suppressWarnings(suppressMessages(col_lbls <- col_lbls %>%
left_join(all_cells_indnt) %>%
mutate(indent_lvl = if_else(is.na(indent_lvl), max(indent_lvl), indent_lvl),
indent = if_else(indent_lvl == min(indent_lvl), FALSE, TRUE)) %>%
select(-indent_lvl)))
}
data_cells <- table_data %>% select(row, col, character)
for(i_choose in unique(col_lbls_meta$i)){
## Select each richest column description in turn, removing that from the dataset
suppressWarnings(suppressMessages( h <- col_lbls %>%
inner_join(RemoveFalseQualifiers(col_lbls_meta, i_choose)) %>%
select(row, col, character) ))
suppressWarnings(suppressMessages(col_lbls <- col_lbls %>%
anti_join(h) ))
## remove cells without information to allow population across rows and columns, ignore, only use where
## the cell has actually been merged
# h <- h %>%
#   filter(!is.na(character))
names(h)[3] <- col_lbls_meta$content[col_lbls_meta$i == i_choose] %>%  unique()
# print(h)
if ( h %>% nrow > 0 ){
data_cells <- data_cells %>%
enhead(header_cells = h, direction = "WNW", drop = FALSE)
}
}
## Do the same now for rows, except dont worry about indentation
row_lbls <- table_body %>%
filter(row %in% row_lbls_meta$row,
!col %in% col_lbls_meta$col)
# rectify(row_lbls)
for(i_choose in unique(row_lbls_meta$i)){
## Select each richest column description in turn, removing that from the dataset
suppressWarnings(suppressMessages(h <- row_lbls %>%
inner_join(RemoveFalseQualifiers(row_lbls_meta, i_choose)) %>%
select(row, col, character) ))
suppressWarnings(suppressMessages( row_lbls <- row_lbls %>%
anti_join(h) ))
## remove cells without information to allow population across rows and columns
# h <- h %>%
#   filter(!is.na(character))
# names(h)[3] <- row_lbls_meta$content[row_lbls_meta$i == i_choose] %>%  unique()
# print(h)
# data_cells <- data_cells %>%
#   enhead(header_cells = h, direction = "NNW", drop = FALSE)
data_cells <- NNW(data_cells, h)
new_name <- row_lbls_meta$content[row_lbls_meta$i == i_choose] %>%  unique()
while(new_name %in% names(data_cells)) new_name <- paste0(new_name, "_")
names(data_cells)[names(data_cells) == "character"] <- new_name
}
data_cells <- data_cells %>%
filter(!is.na(value))
# data_cells
}
TidyTableSafe <- safely(TidyTable)
#a <- TidyTable(docid_page_selected = "28246237_2")
## Here can select trials for specific user
# metadata <- metadata %>%
#   filter(user == "Hebe")
outputs <- map(metadata$docid_page %>% unique, ~ TidyTableSafe(.x))
# saveRDS(outputs, "Output_data/app_extracted_data.Rds")
names(outputs) <- metadata$docid_page %>% unique()
outputs <- transpose(outputs)
# errors <- outputs$error
# errors <- map_lgl(errors, is.null)
# errors[] <- !errors
# mean(errors) # 8% errors, will need to review
# errors[errors]
# saveRDS(errors, "Scratch_data/errors.Rds")
result <- outputs$result
result_success <- result[map_lgl(result, is.tibble)]
result_success <- bind_rows(result_success, .id = "docid_page")
# result_fail    <- result[!map_lgl(result, is.tibble)]
# write_csv(result_success, "temp_hebe.csv")
return(result_success)
}
runAll()
library(tidyxl)
library(unpivotr)
library(tidyverse)
runAll()
library(tidyxl)
library(unpivotr)
library(tidyverse)
library(htmlTable)
new_obj_backup <- readRDS("/home/suso/ihw/tableAnnotator/Server/RDS_TO_HTML/new_obj.rds")
prevcolnames <- new_obj_backup %>% colnames()
new_obj <- readRDS("/home/suso/ihw/tableAnnotator/Server/RDS_TO_HTML/newTables/Full_set_of_tables.Rds")
new_obj %>% colnames()
new_obj <- new_obj %>% mutate( pmid_tbl=paste0(pmid,"_",tbl_n))
filenames_lkp <- new_obj %>% select(pmid,search_round,tbl_n,file_name,original_file_stored) %>% distinct %>% mutate(n = 1) %>% group_by(pmid,tbl_n) %>% mutate(ticker = cumsum(n))
new_obj <- new_obj %>% inner_join(filenames_lkp) %>% select(-n)
new_obj <- new_obj %>% mutate(pmid_tbl = ifelse(ticker > 1, gsub(" ", "", paste(pmid,"v",ticker,"_",tbl_n), fixed = TRUE), pmid_tbl) )
new_obj <- new_obj %>% mutate( indent_lvl=0)
filenames <- new_obj %>% select(pmid_tbl) %>% distinct
df_to_html <- function (tbl_id, df, destination){
atable <- new_obj %>% filter ( pmid_tbl == tbl_id)
# atable %<>%  select(sheet, address, row, col, is_blank, character, bold, italic, indent, data_type,indent_lvl) %>%
#   mutate(is_empty   = is_blank | (!str_detect(character %>% str_to_lower(), "[:alnum:]")),
#          has_no_num = is_blank | (!str_detect(character %>% str_to_lower(), "[0-9]")))
#
#
# all_cells <- atable
#
#
# BlankRow <- function (mydf) {
#   empty_rows <- mydf %>%
#     arrange(row, col) %>%
#     group_by(row) %>%
#     summarise(blank_row = all(is_empty)) %>%
#     ungroup() %>%
#     filter(blank_row) %>%
#     distinct(row) %>%
#     pull(row)
# }
#
#
#
# ## Identify split_header_row as the last empty row IN the first set of contiguos empty rows
# empty_rows <- BlankRow(all_cells)
# null_rows <- setdiff(1:max(all_cells$row), all_cells$row)
# empty_rows <- c(empty_rows, null_rows) %>%
#   sort()
# empty_rows <- tibble(empty_rows = empty_rows, diff = lead(empty_rows, default = 1000L) - empty_rows)
# empty_rows <- empty_rows %>%
#   filter(diff != 1)
# split_header <- empty_rows$empty_rows[1]
#
# # Next identify any rows which are completely blank
# blank_row <- all_cells %>%
#   BlankRow()
#
# # Those which have no information after removing the first column, except a little text in some of the second columns
# first_col_1 <- all_cells %>%
#   filter(!col %in% 1:2) %>%
#   BlankRow()
# first_col_1_spill <- all_cells %>%
#   filter(col == 2, has_no_num) %>%
#   distinct(row) %>%
#   pull(row)
# ## This allows for text only, but not numbers in the second column
# first_col <- intersect(first_col_1, first_col_1_spill)
#
# # Those which have no information after removing the first and last column
# first_last_col <- all_cells %>%
#   group_by(row) %>%
#   mutate(col_max = max(col)) %>%
#   ungroup() %>%
#   filter(!col %in% 1:2, col != col_max) %>%
#   BlankRow()
# first_last_col  <- intersect(first_last_col, first_col_1_spill)
#
# # Those which have only one cell containing information, after removing the first and last column,
# # and which are long rows (>= 4 blank cells)
# first_last_col_wide <- all_cells %>%
#   group_by(row) %>%
#   mutate(col_max = max(col)) %>%
#   ungroup() %>%
#   filter(!col %in% 1:2, col != col_max) %>%
#   group_by(row) %>%
#   summarise(few_p = sum(is_blank) >= 4) %>%
#   filter(few_p) %>%
#   pull(row)
#
# first_last_col_wide <- intersect(first_last_col_wide, first_col_1_spill)
# first_last_col <- union(first_last_col, first_last_col_wide)
#
# first_col <- setdiff(first_col, blank_row)
# first_last_col <- setdiff(first_last_col, c(first_col, blank_row))
#
# ## Add these onto all_cells
# all_cells <- all_cells %>%
#   mutate(blank_row = row %in% blank_row,
#          first_col = row %in% first_col,
#          first_last_col = row %in% first_last_col)
ex <- atable
cols <- (ex %>% dim())[2]
ex[1:cols][ is.na(ex[1:cols]) ] <-FALSE
ex <- ex %>%
mutate_if(is.character, function(x) x %>%
stringi::stri_enc_toutf8())
ex_bk <- ex
ex <- ex_bk
# headers <- paste0('<div class="headers"><div>',paste0(ex[1,]$character,collapse = "</div><div>"),"</div></div>")
headers <- '<div class="headers"><div>'
for (r in 1:max(ex$row)){
rowText <- (ex %>% filter(row == r) %>% filter(character != FALSE) )$character
txtl <- str_length(str_replace_all(str_replace_all(paste0(rowText, collapse= ","),"FALSE",""),",",""))
# print(txtl)
#print(paste0(txtl,"  ", r))
if ( txtl == 0 ) {
ex <- ex %>% filter (! ( row %in% 1:r))
break
}
headers <- paste0(headers, paste0( rowText ,collapse = "</div><div>" ))
}
headers <- paste0(headers,"</div></div>")
ex <- ex %>%
mutate(
# character = if_else(bold, paste0('<p style="font-weight: bold;" > ',character, "</p>"), character)
character = paste0('">',character,"</p>"),
character = if_else(indent, paste0('indent',indent_lvl,' ', character), character),
character = if_else(italic, paste0('italic ', character), character),
character = if_else(first_col, paste0('firstCol ', character), character),
character = if_else(first_last_col, paste0('firstLastCol ', character), character),
character = paste0('<p class="',character)
)
html_res <- htmlTable::htmlTable(rectify( ex ),
align = paste(rep('l',ncol(ex)),collapse=''))
html_res = paste0(headers, html_res)
html_res %>% write(paste0(destination, tbl_id ,".html"))
}
for (r in 1:nrow(filenames)){
try({
print(filenames[r,]$pmid_tbl)
df_to_html(filenames[r,]$pmid_tbl, new_obj, "/home/suso/ihw/tableAnnotator/Server/RDS_TO_HTML/tables/")
})
}
library(readr)
library(tidyverse)
library(dplyr)
library(filesstrings)
first_batch_results <- read_csv("~/ihw/tableAnnotator/annotations/first/first_batch_results.csv")
second_annotations <- read_csv("~/ihw/tableAnnotator/annotations/second/second_annotations.csv")
#First batch did not have the corrupted_text variable. Only a binary corrupted one.
first_batch_results <- first_batch_results %>% mutate(corrupted_text = ifelse(corrupted, "something wrong with the table (First Batch Generic Message)", NA))
first_batch_results <- first_batch_results %>% select(second_annotations %>% colnames)
all_annotations_jul_2019 <- rbind ( first_batch_results, second_annotations)
write.csv(all_annotations_jul_2019, "~/ihw/tableAnnotator/annotations/all_annotations_jul_2019.csv", row.names=FALSE)
first_annotations_good <- first_batch_results %>% filter(is.na(corrupted_text)) %>% select(docid,page) %>% distinct()
second_annotations_good <- second_annotations %>% filter(is.na(corrupted_text)) %>% select(docid,page) %>% distinct()
all_good_annotations <- rbind(first_annotations_good, second_annotations_good) %>% distinct() %>% mutate(compname = paste0(docid,"_",page))
all_distinct_annotations <- all_annotations_jul_2019 %>% mutate(compname = paste0(docid,"_",page)) %>%  select(docid,page,compname) %>% distinct()
all_bad_annotations <- all_distinct_annotations %>% anti_join(all_good_annotations)
dirfiles <- dir("~/ihw/tableAnnotator/Server/HTML_TABLES") %>% data_frame()
colnames(dirfiles)[1] <- "filenames"
dir_files_df <- dirfiles %>% mutate(compname = str_replace(filenames, ".html", ""))  %>% mutate(compname= sub('v[0-9]','',compname) )
all_completed_annotations <- dir_files_df %>% left_join(all_good_annotations) %>% filter( !is.na(docid))
for ( f in all_completed_annotations$filenames){
file.move(paste0("~/ihw/tableAnnotator/Server/HTML_TABLES/",f) , paste0("~/ihw/tableAnnotator/Server/HTML_TABLES_COMPLETED/"))
}
all_failed_annotations <- dir_files_df %>% left_join(all_bad_annotations) %>% filter( !is.na(docid))
for ( f in all_failed_annotations$filenames){
file.move(paste0("~/ihw/tableAnnotator/Server/HTML_TABLES/",f) , paste0("~/ihw/tableAnnotator/Server/HTML_TABLES_FAILED/"))
}
## Directory holding the script
setwd("~/ihw/tableAnnotator/Server/src")
new_obj <- readRDS("Full_set_of_tables.Rds")
View(new_obj)
Full_set_of_tables <- readRDS("~/re_factor_workbook/Outputs/Full_set_of_tables.Rds")
View(Full_set_of_tables)
