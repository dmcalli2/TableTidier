{"version":3,"sources":["existDB.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["// var exist = require('easy-exist');\n//\n// import {EDB_LOGIN} from \"./config\"\n//\n// var simpleSearchCache = {}\n// var cachedQueries = []\n// var maxCacheElements = 40\n//\n// // connect\n// var db = new exist.DB('http://localhost:8080', {\n//     username: EDB_LOGIN.username,\n//     password: EDB_LOGIN.password,\n// });\n//\n//\n// function translateOrderingField(sortField){\n//   var xmlField = \"\"\n//\n//   switch (sortField){\n//         case 'id':\n//         // console.log(\"USE EL ID\");\n//          xmlField = '$hit//@xml:id'\n//          break;\n//         case 'date':\n//         // console.log(\"USE EL DATE\");\n//          xmlField = 'xs:decimal($hit//idno[@type=\"SRONumber\"])'\n//          break;\n//         default:\n//         // console.log(\"USE EL DEFAULT\");\n//          xmlField = '$hit//@xml:id'\n//       }\n//       return xmlField;\n// }\n//\n// function mergeFilter(filterArray){\n//     var filterString = \"\"\n//     if ( filterArray.length > 0 ) {\n//\n//       filterString = \"and ( \"+ filterArray.join(\" or \") +\" ) \"\n//\n//     }\n//     return filterString;\n// }\n//\n// export async function advSearch(q){\n//   //  args, page, limit, orderField, direction\n//\n//     // Caching system\n//     var queryString = JSON.stringify(q)\n//     var cachedResult = simpleSearchCache[queryString];\n//     if ( cachedResult ){\n//       console.log(\"USING CACHED search for: \"+queryString)\n//       return cachedResult\n//     }\n//     // End caching system.\n//\n//     var filters = eval(q.filters)\n//\n//     console.log(filters)\n//     //{\"query\":\"william\",\"person\":\"gfdgfd\",\"copies\":\"fsdfds\",\"minDate\":\"-14999130000000\",\"maxDate\":\"1000335600000\",\"minFees\":\"32\",\"maxFees\":\"32\",\"entry\":\"fdsafdsarew\",\"page\":\"1\",\"limit\":\"20\",\"sortField\":\"@xml:id\",\"direction\":\"ascending\"}\n//\n//     var dateFiltersArray = [];\n//\n//     var volumeFiltersArray = [];\n//\n//     var entryTypeFiltersArray = [];\n//\n//     var entererRoleFiltersArray = [];\n//\n//     for ( var f in filters ){\n//\n//       var filterKey = filters[f].split(\"_\")[0]\n//       var filterValue  = filters[f].split(\"_\")[1]\n//\n//       switch ( filterKey ){\n//         case \"date\":\n//             var minDate = filterValue.split(\"-\")[0]+\"-01-01\"\n//             var maxDate = filterValue.split(\"-\")[1]+\"-12-31\"\n//\n//             dateFiltersArray.push (\"($currentDate >= xs:date('\"+minDate+\"') and $currentDate <= xs:date('\"+maxDate+\"'))\")\n//             break;\n//         case \"volume\":\n//\n//             volumeFiltersArray.push('(lower-case($hit//idno[@type=\"Liber\"]) = \"'+filterValue.toLowerCase().trim()+'\")')\n//\n//             // switch (filterValue) {\n//             //   case \"A\":\n//             //       volumeFiltersArray.push(\"($hit//idno[@type='SRONumber'] < 1265)\")\n//             //     break;\n//             //   case \"B\":\n//             //       volumeFiltersArray.push(\"(($hit//idno[@type='SRONumber'] > 1264) and ($hit//idno[@type='SRONumber'] < 3635))\")\n//             //     break;\n//             //   case \"C\":\n//             //       volumeFiltersArray.push(\"($hit//idno[@type='SRONumber'] > 3634)\")\n//             //     break;\n//             // }\n//             break;\n//         case \"entryType\":\n//\n//             entryTypeFiltersArray.push('count($hit//note[lower-case(@subtype)=\"'+filterValue.toLowerCase().trim()+'\"])')\n//\n//         // case \"entererRole\":\n//         //     switch(filterValue) {\n//         //       case \"Stationer\":\n//         //         entererRoleFiltersArray.push('contains(data($hit//persName[contains(@role, \"enterer\")]/@role),\"stationer\")')\n//         //         break;\n//         //       case \"Non-Stationer\":\n//         //         entererRoleFiltersArray.push('not(contains(data($hit//persName[contains(@role, \"enterer\")]/@role),\"stationer\"))')\n//         //         break;\n//         //     }\n//           break;\n//\n//       }\n//     }\n//\n//     // console.log(dateFiltersArray.join(\" or \"))\n//     var dateFiltersString = mergeFilter(dateFiltersArray)\n//     var volumeFilterString = mergeFilter(volumeFiltersArray)\n//     var entryTypeFilterString = mergeFilter(entryTypeFiltersArray)\n//     // var entererRoleFilterString = mergeFilter(entererRoleFiltersArray)\n//\n//     // console.log(\"DDDA: \"+dateFiltersString)\n//     // console.log(\"DDDASS: \"+JSON.stringify(dateFiltersArray))\n//     // console.log(\"Q::: \"+JSON.stringify(q))\n//     var query  = 'xquery version \"3.1\"; declare default element namespace \"http://www.tei-c.org/ns/1.0\"; declare namespace tei=\"http://www.tei-c.org/ns/1.0\"; declare namespace array=\"http://www.w3.org/2005/xpath-functions/array\"; declare function local:filter($node as node(), $mode as xs:string) as xs:string? { if ($mode eq \"before\") then concat($node, \" \") else concat(\" \", $node) }; import module namespace kwic=\"http://exist-db.org/xquery/kwic\";'\n//     +' let $pageLimit as xs:decimal := '+q.limit+' let $page as xs:decimal := '+q.page+' let $allResults := array { for $hit in collection(\"/db/SRO\")//tei:div'\n//     + (q.query ? \"[ft:query(., '\"+q.query+\"')]\" : '')\n//     +' let $score as xs:float := ft:score($hit) let $currentDate as xs:date := xs:date( data($hit//ab[@type=\"metadata\"]/date[@type=\"SortDate\"]/@when) ) '\n//     // +' let $stockNotes := count($hit//note[@subtype=\"stock\"]) let $enteredNotes := count($hit//note[@subtype=\"entered\"])'\n//     // +' let $isStationer := contains(data($hit//persName[contains(@role, \"enterer\")]/@role),\"stationer\")'\n//     +' where $hit/@type=\"entry\" '\n//\n//     //personName\n//     //+ (q.person ? ' and contains(lower-case(string-join($people//text(),\"\")), \"'+q.person.toLowerCase()+'\")' : '')\n//\n//     + (\n//       q.person ?\n//       q.person.split(\" \").map( (v,i) => v ? ' and contains(lower-case(string-join($hit//persName/descendant::*/text())),\"'+v.toLowerCase()+'\") ' : \"\" ).join(\"\")\n//       : ''\n//     )\n//\n//     //copies\n//     // + entererRoleFilterString\n//     + entryTypeFilterString\n//     + volumeFilterString\n//\n//     //minDate & maxDate\n//     + (q.minDate ? \" and ($currentDate >= xs:date('\"+q.minDate+\"') )\" : \"\")\n//     + (q.maxDate ? \" and ($currentDate <= xs:date('\"+q.maxDate+\"') )\" : \"\")\n//\n//     //minDate & maxDate : from filters\n//     + dateFiltersString\n//\n//     //minFees\n//     + (q.minFees ? ' and data($hit//num[@type=\"totalPence\"]/@value) >= '+q.minFees+' ' : '')\n//     //maxFees\n//     + (q.maxFees ? ' and data($hit//num[@type=\"totalPence\"]/@value) <= '+q.maxFees+' ' : '')\n//\n//     //entry\n//     + (q.entry ? ' and $hit//idno[@type=\"SRONumber\"] = \"'+q.entry+ '\"' : '')\n//     // FILTERS\n//\n//     var post_query = '  let $expanded := kwic:expand($hit) let $sum := array { for $h in $expanded//exist:match return kwic:get-summary($expanded, $h, <config xmlns=\"\" width=\"40\"/>) } return <entry> <date>{ $currentDate }</date> <docid>{data($hit//@xml:id)}</docid> <doc>{$hit}</doc> <sum>{$sum}</sum> </entry> } let $page := if( $page < 1 ) then 1 else $page let $resultsCount as xs:decimal := array:size($allResults) let $firstEntry := (($page - 1)*$pageLimit)+1 let $firstEntry := if( $firstEntry > $resultsCount) then ( if ( ($resultsCount - $pageLimit) < 0) then 1 else $resultsCount - $pageLimit ) else $firstEntry let $maxpage as xs:double := math-ext:ceil($resultsCount div $pageLimit) let $pagesToReturn := if( ($firstEntry + $pageLimit) > $resultsCount ) then ( $pageLimit - ( $firstEntry + $pageLimit -$resultsCount )+1 ) else $pageLimit return <results> <paging> <current>{$page}</current> <returned>{$pagesToReturn}</returned> <total>{$resultsCount}</total> <last>{$maxpage}</last> </paging> <entries>{array:flatten(array:subarray($allResults, $firstEntry, $pagesToReturn))}</entries> </results> ';\n//\n//     //query = query + ' and contains($people//role/text(), \"enterer\") '\n//\n//     if ( q.sortField ){\n//       query = query + ' order by '+translateOrderingField(q.sortField).trim()+' '+q.direction+' '\n//     } else {\n//       query = query + ' order by $score descending '\n//     }\n//\n//     var query = query+post_query\n//\n//     console.log(query)\n//\n//     return new Promise( function (Resolve,Reject){\n//\n//         try{\n//           db.query(query,{wrap:\"no\"})\n//               .then(function(result) {\n//                 //  console.log('xQuery result:', result);\n//\n//                   try{ // very crude implementation of a cache. to speed up repeating searches.\n//\n//                     if( cachedQueries.length > maxCacheElements ){\n//                         delete simpleSearchCache[cachedQueries.shift()]\n//                     }\n//\n//                     simpleSearchCache[queryString] = result\n//                     cachedQueries.push(queryString)\n//\n//                   }catch ( cacheError){\n//                     console.log(cacheError)\n//                   }\n//\n//\n//                   Resolve(result)\n//                 })\n//\n//         } catch (error){\n//            Reject (\"Something failed in the ExistDB Module: \"+error)\n//         }\n//\n//       });\n//\n//   }\n//\n// export async function textSearch(query, page, limit, orderField, direction){\n//\n//     var query  = 'xquery version \"3.1\"; import module namespace kwic=\"http://exist-db.org/xquery/kwic\"; declare default element namespace \"http://www.tei-c.org/ns/1.0\"; declare namespace tei=\"http://www.tei-c.org/ns/1.0\"; declare namespace array=\"http://www.w3.org/2005/xpath-functions/array\"; let $pageLimit as xs:decimal := '+limit+' let $page as xs:decimal := '+page+' '\n//           +'let $allResults := array { for $hit in collection(\"/db/SRO\")//tei:div[ft:query(., \"'+query+'\")]'\n//           +' let $score as xs:float := ft:score($hit) where $hit/@type=\"entry\"'\n//\n//     var post_query = ' let $sum := kwic:summarize($hit, <config xmlns=\"\" width=\"100\"/>) return <comp><doc>{$hit}</doc><sum>{$sum}</sum></comp> } '\n//           +' let $resultsCount as xs:decimal := array:size($allResults) let $maxpage as xs:double := math-ext:ceil($resultsCount div $pageLimit) let $firstEntry := if ( $page > $maxpage ) then ($maxpage * $pageLimit) - ($pageLimit - 1) else ($page * $pageLimit) - ($pageLimit - 1) let $offset := if ( ($firstEntry + $pageLimit) > $resultsCount ) then ($firstEntry + $pageLimit) - $resultsCount else 0 let $pagesToReturn := $pageLimit - $offset return <results> <paging> <current>{$page}</current> <last>{$maxpage}</last> <returned>{$pagesToReturn}</returned> <total>{$resultsCount}</total> </paging> <entries> { for $hita in array:flatten(array:subarray($allResults, $firstEntry, $pagesToReturn)) let $hit := $hita/doc return <entry> <docid>{data($hit//@xml:id)}</docid> <date>{ if (data($hit//ab[@type=\"metadata\"]/date/@when)) then data($hit//ab[@type=\"metadata\"]/date/@when) else data($hit//ab[@type=\"metadata\"]/date/@notBefore) }</date> <people>{ for $pers in $hit//persName return <person> <role>{data($pers/@role)}</role> <name> <title> {normalize-space($pers/text()[last()])} </title> <forename>{$pers/forename/text()}</forename> <surname>{$pers/surname/text()}</surname> </name> </person> } </people> {$hit} {$hita/sum} </entry> } </entries> </results> '\n//\n//\n//     if ( orderField ){\n//       query = query + ' order by $hit//'+orderField.trim()+' '+direction+' '\n//     } else {\n//       query = query + ' order by $score descending '\n//     }\n//\n//     var query = query+post_query\n//\n//     console.log(query)\n//\n//     return new Promise( function (Resolve,Reject){\n//\n//         try{\n//           db.query(query,{wrap:\"no\"})\n//               .then(function(result) {\n//                   //console.log('xQuery result:', result);\n//                   Resolve(result)\n//                 })\n//\n//         } catch (error){\n//            Reject (\"Something failed in the ExistDB Module: \"+error)\n//         }\n//\n//       });\n//\n//   }\n//\n//   export async function getAllEntriesOrdered(){\n//\n//       var query = 'xquery version \"3.0\";'+\n//                   'declare default element namespace \"http://www.tei-c.org/ns/1.0\";'+\n//                   'declare namespace tei=\"http://www.tei-c.org/ns/1.0\";'+\n//                   '<entries>'+\n//                   '{'+\n//                   ' for $hit in collection(\"/db/SRO\")//tei:div[@type=\"entry\"]'+\n//                   'let $score as xs:float := ft:score($hit) where $hit/@type=\"entry\" order by $score descending return <entry> <docid>{data($hit/@xml:id)}</docid> <score>{data($score)}</score> <date>{ if (data($hit//ab[@type=\"metadata\"]/date/@when)) then data($hit//ab[@type=\"metadata\"]/date/@when) else data($hit//ab[@type=\"metadata\"]/date/@notBefore) }</date> <stationers>{ for $stat in $hit//persName where $stat/@role=\"stationer\" return <name> {string-join( ($stat/forename,$stat/surname), \", \")} </name> } </stationers> <doc>{ for $item in $hit/p return <item>{fn:string-join($item//text(),\" \")}</item> }</doc> </entry> } </entries>'\n//\n//       return new Promise( function (Resolve,Reject){\n//\n//           try{\n//             db.query(query,{wrap:\"no\"})\n//                 .then(function(result) {\n//                     //console.log('xQuery result:', result);\n//                     Resolve(result)\n//                   })\n//\n//           } catch (error){\n//              Reject (\"Something failed in the ExistDB Module: \"+error)\n//           }\n//\n//         });\n//\n//     }\n//\n//\n//     export async function getAllPeople(){\n//\n//         return new Promise( function (Resolve,Reject){\n//             try{\n//               db.executeStoredQuery(\"/QS/allPeople.xq\")\n//                   .then(function(result) {\n//                       //console.log('xQuery result:', result);\n//                       Resolve(result)\n//                     })\n//\n//             } catch (error){\n//                Reject (\"Something failed in the ExistDB Module: \"+error)\n//             }\n//           });\n//       }\n//\n//     export async function getAllEntries(){\n//\n//         return new Promise( function (Resolve,Reject){\n//             try{\n//               db.executeStoredQuery(\"/QS/allEntries.xq\")\n//                   .then(function(result) {\n//                       Resolve(result)\n//                     })\n//\n//             } catch (error){\n//                Reject (\"Something failed in the ExistDB Module: \"+error)\n//             }\n//\n//           });\n//\n//       }\n//\n//       export async function getEntry(entryID){\n//         var query = 'xquery version \"3.1\"; declare default element namespace \"http://www.tei-c.org/ns/1.0\"; declare namespace tei=\"http://www.tei-c.org/ns/1.0\"; for $coll in collection(\"/db/SRO\") for $hit in $coll//tei:div[@type=\"entry\"] where $hit/@xml:id = \"'+entryID+'\" return $hit';\n//         console.log(query);\n//\n//         return new Promise( function (Resolve,Reject){\n//\n//             try{\n//               db.query(query,{wrap:\"no\"})\n//                   .then(function(result) {\n//                       //console.log('xQuery result:', result);\n//                       Resolve(result)\n//                     })\n//\n//             } catch (error){\n//                Reject (\"Something failed in the ExistDB Module: \"+error)\n//             }\n//\n//           });\n//\n//         }\n//\n//       export async function getAllEntriesPaged(page,limit){\n//\n//         var query = 'xquery version \"3.1\"; declare default element namespace \"http://www.tei-c.org/ns/1.0\"; declare namespace tei=\"http://www.tei-c.org/ns/1.0\"; declare namespace array=\"http://www.w3.org/2005/xpath-functions/array\"; let $pageLimit as xs:decimal := '+limit+' let $page as xs:decimal := '+page+' let $allResults := array { for $hit in collection(\"/db/SRO\")//tei:div where $hit/@type=\"entry\" return <comp><doc>{$hit}</doc></comp> } let $resultsCount as xs:decimal := array:size($allResults) let $maxpage as xs:double := math-ext:ceil($resultsCount div $pageLimit) let $firstEntry := if ( $page > $maxpage ) then ($maxpage * $pageLimit) - ($pageLimit - 1) else ($page * $pageLimit) - ($pageLimit - 1) let $offset := if ( ($firstEntry + $pageLimit) > $resultsCount ) then ($firstEntry + $pageLimit) - $resultsCount else 0 let $pagesToReturn := $pageLimit - $offset return <results> <paging> <current>{$page}</current> <last>{$maxpage}</last> <returned>{$pagesToReturn}</returned> <total>{$resultsCount}</total> </paging> <entries> { for $hita in array:flatten(array:subarray($allResults, $firstEntry, $pagesToReturn)) let $hit := $hita/doc return <entry> <docid>{data($hit//@xml:id)}</docid> <date>{ if (data($hit//ab[@type=\"metadata\"]/date/@when)) then data($hit//ab[@type=\"metadata\"]/date/@when) else data($hit//ab[@type=\"metadata\"]/date/@notBefore) }</date> <people>{ for $pers in $hit//persName return <person> <role>{data($pers/@role)}</role> <name> <title> {normalize-space($pers/text()[last()])} </title> <forename>{$pers/forename/text()}</forename> <surname>{$pers/surname/text()}</surname> </name> </person> } </people> {$hit} </entry> } </entries> </results>';\n//\n//         console.log(query);\n//\n//         return new Promise( function (Resolve,Reject){\n//\n//             try{\n//               db.query(query,{wrap:\"no\"})\n//                   .then(function(result) {\n//                       //console.log('xQuery result:', result);\n//                       Resolve(result)\n//                     }).catch(function (rejected){\n//                       console.log(rejected)\n//                     })\n//\n//             } catch (error){\n//                Reject (\"Something failed in the ExistDB Module: \"+error)\n//             }\n//\n//           });\n//         }\n//\n//\n//\n// // USAGE EXAMPLE OF THE EASY-EXIST MODULE\n//\n// // PUT a document\n// // db.put('/my-collection/my-document', body)\n// //\n// //     // Get the body of a document\n// //     .then(function() {\n// //         return db.get('/my-collection/my-document');\n// //     })\n// //     .then(function(doc) {\n// //         console.log('Document Body:', doc);\n// //     })\n// //\n// //     // Execute xQuery\n// //     .then(function() {\n// //         return db.query('collection(\"my-collection\")/message/body');\n// //     })\n// //     .then(function(result) {\n// //         console.log('xQuery result:', result);\n// //     })\n// //\n// //     // Delete document\n// //     .then(function() {\n// //         return db.delete('/my-collection/my-document');\n// //     })\n// //     .then(function() {\n// //         console.log('Document Deleted');\n// //     });\n// //\n//\n// //WASUsPS\n"],"file":"existDB.js"}